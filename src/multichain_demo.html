<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Graph Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .floating-div {
            position: absolute;
            top: 0;
            right: 0;
            width: 150px;
            background-color: lightgray;
            z-index: 1;
            padding: 5px;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- Floating Div -->
    <div class="floating-div">
        <input type="text" id="connectExtensionInput" value="nonfpcflonapegmnfeafnddgdniflbnk" />
        <br>
        <button id="connectExtensionButton">Connect Extension</button>
        <button id="connectButton">Connect Wallet</button>
        <br><br>
        <a href="https://chainlist.org/chain/11155111">Sepolia</a>
        <br>
        <a href="https://chainlist.org/chain/59141">Linea Sepolia</a>
        <br>
        <a href="https://chainlist.org/chain/421614">Arbitrum Sepolia</a>
        <br>
        <a href="https://chainlist.org/chain/11155420">OP Sepolia</a>
        <br>
        <a href="https://chainlist.org/chain/168587773">Blast Sepolia</a>
    </div>

    <!-- Modal Structure -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <p id="modal-text"></p>
        </div>
    </div>

<script>
document.addEventListener("DOMContentLoaded", function() {
    //
    // Constants
    //
    const BridgeContracts = {
        'eip155:5': {
        contractAddress: '0xdead',
        sendsTo: ['eip155:111555111']
        }
    }

    const pastelColors = [
        "#e8b6ae", "#f0c1ad", "#eed0ba", "#ebdec6", "#cdc0d6",
        "#b8b1cf", "#959bad", "#97aeb8", "#a5bcc1", "#b2c9c9",
        "#9ac7a8", "#b8dbc9", "#c5e3d2", "#d1ebdb", "#d6e1c8",
        "#e5c28c", "#e8d097", "#edd9aa", "#f2e6bb", "#f9f3dd"
    ];
    const NODE_PADDING = 20;
    const NODE_SCALE = 1.33;

    //
    // State
    //
    let extensionPort;
    let jsonRpcId;
    let currentSessionScopes = {};
    let accounts = [];
    let scopeStrings = [];

    let nodes = [];
    let links = [];
    for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
            links.push({ source: nodes[i].id, target: nodes[j].id });
        }
    }


    //
    // Helpers
    //

    // Dapp <-> Wallet Connection Initialization
    async function connectExtension() {
        const extensionId = document.getElementById("connectExtensionInput").value;
        try {
        extensionPort = chrome.runtime.connect(extensionId); // externally_connectable
        extensionPort.onMessage.addListener((msg) => {
            const { data: { method, params } } = msg;
            // Subscription Events
            if (method === "wallet_notify") {
            handleEthSubscriptionDisplay(
                params.scope,
                params.notification.params.result.number,
            );
            // Permission Events
            } else if (method === "wallet_sessionChanged") {
            onNewSessionScopes(params.sessionScopes);
            }
            console.log(msg.data);
        });

        // Dapp Initialization
        checkWalletConnection();
        } catch (error) {
        console.error(error);
        alert("Failed to connect to extension!");
        }
    }

    // Permission Handling
    async function onNewSessionScopes(sessionScopes) {
        const oldScopeStrings = scopeStrings;
        const eip155ScopeStrings = Object.keys(sessionScopes).filter((scopeString) =>
        /eip155:[0-9]+/u.test(scopeString),
        );

        const eip155AccountsSet = new Set();

        eip155ScopeStrings.forEach((scopeString) => {
        const scopeObject = sessionScopes[scopeString];

        scopeObject.accounts.forEach((account) => {
            const address = account.split(":")[2];
            eip155AccountsSet.add(address);
        });
        });

        currentSessionScopes = sessionScopes;
        accounts = [...eip155AccountsSet];
        scopeStrings = [...eip155ScopeStrings];


        // updateConnectedAccountsDisplay();
        // updateScopeSelectOptions();
        // updateMethodButtonsState();

        oldScopeStrings.forEach((oldScopeString) => {
            if (!scopeStrings.includes(oldScopeString)) {
                removeNode(oldScopeString)
            }
        });
        scopeStrings.forEach(newScopeString => {
            if (!oldScopeStrings.includes(newScopeString)) {
                addNode(newScopeString, 'HELLO')
            }
        })

        console.log({nodes, links})
    }

    // Permission Initialization
    async function connectWallet() {
        if (!extensionPort) {
        alert("Connect to extension first.");
        return;
        }
        try {

        const { sessionScopes } = await extensionPortRequest({
            method: "wallet_createSession",
            params: {
                eip155: {
                    references: ["11155111", "59141", "421614", "11155420", "168587773"],
                    methods: [
                        "eth_sendTransaction",
                        "eth_subscribe",
                    ],
                    notifications: ["eth_subscription"],
                },
            },
        });

        await onNewSessionScopes(sessionScopes);
        } catch (error) {
        console.error(error);
        alert("Failed to connect wallet!");
        }
    }

    async function checkWalletConnection() {
        try {
        const { sessionScopes } = await extensionPortRequest({
            method: "wallet_getSession",
        });
        await onNewSessionScopes(sessionScopes);
        } catch (error) {
        console.error("Failed to check wallet connection:", error);
        alert("Failed to check wallet connection");
        }
    }

    //
    // externally_connectable helpers:
    // normally this would be abstracted away
    // by a helper library
    //

    function generateJsonRpcId(opts) {
        let max = Number.MAX_SAFE_INTEGER;
        jsonRpcId = jsonRpcId ?? Math.floor(Math.random() * max);

        jsonRpcId = jsonRpcId % max;
        jsonRpcId += 1;
        return jsonRpcId;
    }

    async function extensionPortRequest(request) {
        const id = generateJsonRpcId();

        extensionPort.postMessage({
        type: "caip-x",
        data: {
            jsonrpc: "2.0",
            id,
            ...request,
        },
        });

        return new Promise((resolve, reject) => {
        const listener = (msg) => {
            if (msg.type === "caip-x" && msg.data.id === id) {
            const { result, error } = msg.data;
            if (result) {
                resolve(result);
            } else {
                reject(error);
            }
            extensionPort.onMessage.removeListener(listener);
            }
        };

        extensionPort.onMessage.addListener(listener);
        });
    }

    //
    // D3
    //
    function generateLabel() {
        return accounts.map(account => `${account}: ${(Math.random() * 10).toFixed(3)}`).join('\n');
    }

    const svg = d3.select("body").append("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(400)) // Further increased distance
        .force("charge", d3.forceManyBody().strength(-1600)) // Further increased negative strength
        .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
        .force("collide", d3.forceCollide().radius(d => getRadius(d.label) * NODE_SCALE + NODE_PADDING + 40)); // Further increased radius

    const link = svg.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("stroke-width", 2)
        .attr("stroke", "#999")
        .on("click", function(event, d) {
            const sourceNode = nodes.find(node => node.id === d.source.id);
            const targetNode = nodes.find(node => node.id === d.target.id);
            showModal(`Source: ${sourceNode.label}\nTarget: ${targetNode.label}`);
        });

    const node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter().append("g")
        .on("click", function(event, d) {
            showModal(d.label);
        });

    node.append("circle")
        .attr("r", d => getRadius(d.label) * NODE_SCALE + NODE_PADDING)
        .attr("fill", () => pastelColors[Math.floor(Math.random() * pastelColors.length)]);

    const text = node.append("text")
        .attr("text-anchor", "middle");

    text.selectAll("tspan")
        .data(d => d.label.split('\n'))
        .enter()
        .append("tspan")
        .attr("x", 0)
        .attr("dy", (d, i) => i === 0 ? 0 : "1.2em")
        .text(d => d);

    simulation.on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node
            .attr("transform", d => `translate(${d.x},${d.y})`);
    });


    function getRadius(text) {
        const context = document.createElement("canvas").getContext("2d");
        context.font = "10px sans-serif";
        const lines = text.split("\n");
        const maxWidth = Math.max(...lines.map(line => context.measureText(line).width));
        const lineHeight = 10; // Approximate line height
        const textHeight = lines.length * lineHeight;
        return Math.max(20, Math.sqrt(maxWidth * maxWidth + textHeight * textHeight) / 2 + 10); // Ensure a minimum radius of 20
    }

    window.addEventListener("resize", () => {
        svg.attr("width", window.innerWidth)
            .attr("height", window.innerHeight);
        simulation.force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
        simulation.alpha(1).restart(); // Restart simulation to adjust positions
    });

    // Modal functionality
    const modal = document.getElementById("myModal");
    const modalText = document.getElementById("modal-text");
    const span = document.getElementsByClassName("close")[0];

    function showModal(content) {
        modalText.textContent = content;
        modal.style.display = "block";
    }

    span.onclick = function() {
        modal.style.display = "none";
    }

    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }

    // setTimeout(() => {
    //     nodes[0].label = generateLabel();
    //     text.selectAll("tspan").remove();
    //     text.selectAll("tspan")
    //         .data(d => d.label.split('\n'))
    //         .enter()
    //         .append("tspan")
    //         .attr("x", 0)
    //         .attr("dy", (d, i) => i === 0 ? 0 : "1.2em")
    //         .text(d => d);
    //     node.select("circle").attr("r", d => getRadius(d.label) * NODE_SCALE + NODE_PADDING);
    //     simulation.alpha(1).restart(); // Restart simulation to adjust positions
    // }, 3000);

    // Flash an edge
    // setTimeout(() => {
    //     const randomLink = d3.select(link.nodes()[Math.floor(Math.random() * links.length)]);
    //     const originalColor = randomLink.attr("stroke");
    //     randomLink.attr("stroke", "green");
    //     setTimeout(() => {
    //         randomLink.attr("stroke", originalColor);
    //     }, 3000);
    // }, 5000);


    // setTimeout(() => {
    //     const randomLink = links[Math.floor(Math.random() * links.length)];
    //     const linkSelection = d3.select(link.nodes()[links.indexOf(randomLink)]);
    //     const sourceNode = nodes.find(node => node.id === randomLink.source.id);
    //     const targetNode = nodes.find(node => node.id === randomLink.target.id);

    //     const edgeLabel = svg.append("text")
    //         .attr("x", (sourceNode.x + targetNode.x) / 2)
    //         .attr("y", (sourceNode.y + targetNode.y) / 2)
    //         .attr("dy", -5)
    //         .attr("text-anchor", "middle")
    //         .attr("fill", "green")
    //         .text("sending...");

    //     setTimeout(() => {
    //         edgeLabel.remove();
    //     }, 3000);
    // }, 5000);


    function addNode(id, label) {
        const newNode = { id, label: generateLabel() };
        nodes.push(newNode);

        // TODO: GET RID OF THIS
        if (nodes.length) {
            const randomNode = nodes[Math.floor(Math.random() * (nodes.length - 1))];
            links.push({ source: randomNode.id, target: newNode.id });
        }

        // Update the simulation with the new node and link
        simulation.nodes(nodes);
        simulation.force("link").links(links);

        // Add the new node to the SVG
        const newNodeSelection = svg.select(".nodes")
            .selectAll("g")
            .data(nodes)
            .enter()
            .append("g")
            .on("click", function(event, d) {
                showModal(d.label);
            });

        newNodeSelection.append("circle")
            .attr("r", d => getRadius(d.label) * NODE_SCALE + NODE_PADDING)
            .attr("fill", () => pastelColors[Math.floor(Math.random() * pastelColors.length)]);

        const newText = newNodeSelection.append("text")
            .attr("text-anchor", "middle");

        newText.selectAll("tspan")
            .data(d => d.label.split('\n'))
            .enter()
            .append("tspan")
            .attr("x", 0)
            .attr("dy", (d, i) => i === 0 ? 0 : "1.2em")
            .text(d => d);

        // Restart the simulation
        simulation.alpha(1).restart();
    }

    function removeNode(id) {
        nodes = nodes.filter(node => node.id !== randomNode.id);
        links = links.filter(link => link.source.id !== randomNode.id && link.target.id !== randomNode.id);

        // Update the simulation with the removed node and links
        simulation.nodes(nodes);
        simulation.force("link").links(links);

        // Remove the node and its edges from the SVG
        svg.select(".nodes").selectAll("g")
            .data(nodes, d => d.id)
            .exit().remove();

        svg.select(".links").selectAll("line")
            .data(links, d => `${d.source.id}-${d.target.id}`)
            .exit().remove();

        // Restart the simulation
        simulation.alpha(1).restart();
    }

    // DOM
    document.getElementById("connectExtensionButton").addEventListener("click", connectExtension);
    document.getElementById("connectButton").addEventListener("click", connectWallet);
});
</script>
</body>
</html>
